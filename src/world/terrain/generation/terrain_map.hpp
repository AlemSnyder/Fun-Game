#pragma once

#include "map_tile.hpp"

namespace terrain {
namespace generation {

/**
 * @brief Map of terrain
 *
 * @details Map generated by world generation.
 */
class TerrainMacroMap {
 private:
    MacroDim width_;
    MacroDim height_;

    std::vector<MapTile> terrain_map_;

 public:
    /**
     * @brief Create a new TerrainMacroMap object
     *
     * @details default constructor
     */
    inline TerrainMacroMap() : width_(0), height_(0){};

    /**
     * @brief Create a new TerrainMacroMap
     *
     * @param std::vector<MapTile> map data
     * @param size_t map width
     * @param size_t map height
     */
    inline TerrainMacroMap(
        std::vector<MapTile> terrain_map, size_t width, size_t height
    ) :
        width_(width),
        height_(height), terrain_map_(terrain_map) {
        assert(terrain_map_.size() == width_ * height_);
    };

    /**
     * @brief Get the MapTile at a given position
     *
     * @param size_t i x axis
     * @param size_t j y axis
     */
    const MapTile&
    get_tile(size_t i, size_t j) const {
        assert(i < width_ && j < height_);
        return terrain_map_[height_ * j + i];
    }

    /**
     * @brief Get the color representation of the given position
     *
     * @param size_t i x axis
     * @param size_t j y axis
     */
    png_byte
    get_color(size_t i, size_t j) const {
        return get_tile(i, j).get_type_id();
    }

    /**
     * @brief iterator to first map tile
     */
    const auto
    begin() const {
        return terrain_map_.begin();
    }

    /**
     * @brief iterator past last map tile
     */
    const auto
    end() const {
        return terrain_map_.end();
    }

    /**
     * @brief Get the map vector
     *
     * @return `std::vector<MapTile>&` vector of map tiles
     */
    const std::vector<MapTile>&
    data() const {
        return terrain_map_;
    }

    /**
     * @brief Get the width of the map
     *
     * @return `MacorDim` width of the map
     */
    MacroDim
    get_width() const {
        return width_;
    }

    /**
     * @brief Get the height of the map
     *
     * @return `MacorDim` height of the map
     */
    MacroDim
    get_height() const {
        return height_;
    }
};

class TerrainMapRepresentation {
 private:
    const TerrainMacroMap& terrain_map_;
    unsigned int tile_size_in_pixels_;
    unsigned int tile_border_size_;

 public:
    TerrainMapRepresentation(
        const TerrainMacroMap& map, unsigned int tile_size = 4,
        unsigned int tile_border = 1
    ) :
        terrain_map_(map),
        tile_size_in_pixels_(tile_size), tile_border_size_(tile_border) {}

    [[nodiscard]] inline size_t
    get_height() const {
        return tile_size_in_pixels_ * terrain_map_.get_height();
    }

    [[nodiscard]] inline size_t
    get_width() const {
        return tile_size_in_pixels_ * terrain_map_.get_width();
    }

    [[nodiscard]] std::array<png_byte, 3> get_color(size_t i, size_t j) const;
};

} // namespace generation

} // namespace terrain
