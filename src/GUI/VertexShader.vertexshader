#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexColor;
//layout(location = 2) in int packed_normal;
layout(location = 2) in vec3 normal_in;

// Output data ; will be interpolated for each fragment.
out vec3 fragmentColor;
out vec3 normal;
//out vec3 lightDir;
// Values that stay constant for the whole mesh.
uniform mat4 MVP;
//uniform vec3 lightDir_vs;

void main(){
	//normal = vec3( mod(packed_normal / 4, 2),  mod(packed_normal / 2 , 2), mod( packed_normal , 2) ) - vec3( mod(packed_normal / 32, 2),  mod(packed_normal / 16 , 2), mod( packed_normal / 8 , 2) );

	/*if (packed_normal == 1){
		normal = vec3(0,0,1);
	}
	else if (packed_normal == 2){
		normal = vec3(0,1,0);
	}
	else if (packed_normal == 4){
		normal = vec3(1,0,0);
	}
	else if (packed_normal == 8){
		normal = vec3(0,0,-1);
	}
	else if (packed_normal == 16){
		normal = vec3(0,-1,0);
	}
	else if (packed_normal == 32){
		normal = vec3(-1,0,0);
	}
	else if (packed_normal == 0){
		normal = vec3(.5,.5,.5);
	}
	else {
		normal = vec3(1,1,1);
	}*/
	normal = normal_in;
	//lightDir = lightDir_vs;

	// Output position of the vertex, in clip space : MVP * position
	gl_Position =  MVP * vec4(vertexPosition_modelspace,1);

	// The color of each vertex will be interpolated
	// to produce the color of each fragment
	fragmentColor = vertexColor;
}